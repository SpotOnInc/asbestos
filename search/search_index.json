{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"asbestos","text":"<p>A mock data system for Snowflake. Test your code using real Snowflake calls just by swapping out the cursor and return whatever data you want, getting away from messy mocks and the occasional odd side effect.</p> <p><code>asbestos</code> was developed in-house at SpotOn to solve easy mocking of Snowflake calls across multiple codebases. It fits our use case fully, but if it doesn't implement something you need, we're happy to take pull requests!</p> <p>Why 'Asbestos'?</p> <p>In the classic film The Wizard of Oz, the fake snow that they use in the poppy field is pure asbestos. Thankfully there are much better ways of generating fake snow now that are much less carcinogenic -- most modern fake snow is made from paper byproducts and dyed cellulose fibers!</p>"},{"location":"#installation","title":"Installation","text":"<p>Grab it from PyPI with <code>pip install asbestos</code> or <code>poetry add asbestos</code>. This is a pure Python package and has no required dependencies of its own. Asbestos takes advantage of modern language features and only supports Python 3.9+.</p> <p>Note</p> <p><code>asbestos</code> is not a replacement for Snowflake's official connector. It's intended to run alongside the official connector and let you selectively stub out calls that either aren't finished yet or need to return dummy data for testing purposes.</p>"},{"location":"#getting-started","title":"Getting started","text":""},{"location":"#setup","title":"\u27a1\ufe0f Setup","text":""},{"location":"#usage","title":"\u27a1\ufe0f Usage","text":""},{"location":"#reference","title":"\u27a1\ufe0f Reference","text":""},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#asbestos.asbestos_cursor","title":"<code>asbestos.asbestos_cursor()</code>","text":"<p>Stand-in for Snowflake's Python Connector.</p>"},{"location":"reference/#asbestos.asbestos.AsbestosConfig","title":"<code>asbestos.asbestos.AsbestosConfig</code>","text":"<p>The cursor in Asbestos takes a single argument of an instance of <code>AsbestosConfig</code>. When using the built-in <code>asbestos_cursor()</code>, it automatically uses a global config built just for this purpose.</p> <p>Hey!</p> <p>If you're using the default <code>asbestos_cursor()</code>, you do not need to instantiate your own instance of this class. Just import the existing version from <code>asbestos.config</code>.</p>"},{"location":"reference/#asbestos.asbestos.AsbestosConfig.clear_queries","title":"<code>clear_queries()</code>","text":"<p>Remove all the registered queries and responses.</p>"},{"location":"reference/#asbestos.asbestos.AsbestosConfig.register","title":"<code>register(query, response, data=None, force_pagination_size=None)</code>","text":"<p>Asbestos will watch for any call that includes the query passed in and return the response you save. If data is provided with the query, the response will only be returned if the query and data match exactly. A query with no data will match any data passed in, though.</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; config.register(query=\"A\", response=\"B\")\n&gt;&gt;&gt; cursor.execute(\"A\")\n&gt;&gt;&gt; cursor.fetchone()\n\"B\"  # This matches, so we get what we expect\n</code></pre> <p>Because our registered response doesn't have data attached to it, it will match all queries that are more specific.</p> <pre><code>&gt;&gt;&gt; cursor.execute(\"A\", (\"AAA\",))\n&gt;&gt;&gt; cursor.fetchone()\n\"B\"\n</code></pre> <p>However, if our registered response is more specific than the query, it will not match.</p> <pre><code>&gt;&gt;&gt; config.clear_queries()\n&gt;&gt;&gt; config.register(query=\"A\", data=\"D\", response=\"B\")\n&gt;&gt;&gt; cursor.execute(\"A\", (\"D\",))\n&gt;&gt;&gt; cursor.fetchone()\n\"B\"  # this matches the saved query exactly, so we get the expected response\n&gt;&gt;&gt; cursor.execute(\"A\")\n&gt;&gt;&gt; cursor.fetchone()\n{}  # default response\n&gt;&gt;&gt; cursor.execute(\"A\", (\"E\",))  # extra data doesn't match!\n&gt;&gt;&gt; cursor.fetchone()\n{}  # default response\n</code></pre> <p>If you're dealing with a <code>fetchmany()</code> call and need to control how many results are returned regardless of what the code requests, pass the return count into <code>force_pagination_size</code>. This will override both <code>cursor.arraysize</code> and the number passed into <code>fetchmany</code>.</p> <pre><code>&gt;&gt;&gt; config.register(\n...     query=\"A\",\n...     response=[{'a': 1}, {'b': 2}],\n...     force_pagination_size=1\n... )\n&gt;&gt;&gt; cursor.execute(\"A\")\n&gt;&gt;&gt; cursor.fetchmany(50)\n{'a': 1}  # because we overrode the value when registering\n</code></pre> <p>Registering a query will return the <code>sfqid</code> of the query that was just registered. This can be used later with <code>get_results_from_sfqid()</code> and <code>remove_query_by_sfqid()</code> to manipulate the query after it's been registered.</p>"},{"location":"reference/#asbestos.asbestos.AsbestosConfig.register_ephemeral","title":"<code>register_ephemeral(query, response, data=None, force_pagination_size=None)</code>","text":"<p>Works the same way as <code>AsbestosConfig.register()</code> with the only difference being that after this query is called, it is removed from the list. This can be used for tests or other situations where you need a call to succeed only once.</p>"},{"location":"reference/#asbestos.asbestos.AsbestosConfig.remove_query_by_sfqid","title":"<code>remove_query_by_sfqid(sfqid)</code>","text":"<p>New in 1.6.0!</p> <p>If you need to remove a specific registered query (ephemeral or not), pass its <code>sfqid</code> in here. Returns True if the query was found and removed.</p> <pre><code>&gt;&gt;&gt; query_id = config.register(query=\"A\", response=\"B\")\n&gt;&gt;&gt; len(config.query_map)\n1  # one query registered\n&gt;&gt;&gt; config.remove_query_by_sfqid(query_id)\nTrue  # the query was found and removed\n&gt;&gt;&gt; len(config.query_map)\n0  # no queries left\n</code></pre>"},{"location":"reference/#asbestos.asbestos.AsbestosCursor","title":"<code>asbestos.asbestos.AsbestosCursor</code>","text":"<p>Analogue for Snowflake's cursor object.</p> <p>If you're wanting to use this as a manually-constructed object, you will need to create an instance of AsbestosConfig first, then pass it into your cursor. The easiest way to handle this is to treat it like the instantiation that is used in Asbestos:</p> <pre><code>import contextlib\n\nfrom asbestos import AsbestosCursor, AsbestosConfig\n\n\nmyconfig = AsbestosConfig()\n\n# set up myconfig here\n...\n\n@contextlib.contextmanager\ndef my_custom_cursor() -&gt; AsbestosCursor:\n    yield AsbestosCursor(config=myconfig)\n</code></pre>"},{"location":"reference/#asbestos.asbestos.AsbestosCursor.sfqid","title":"<code>sfqid</code>  <code>property</code>","text":"<p>Retrieve the ID of the last-run query or None.</p> <p>In Snowflake, the <code>sfqid</code> is an ID that's attached to every query that's run. In <code>asbestos</code>, it's a random number attached to a query. If you pass this value to <code>get_results_from_sfqid()</code>, it will reset the cursor to the values from that query to effectively run it again.</p>"},{"location":"reference/#asbestos.asbestos.AsbestosCursor.close","title":"<code>close()</code>","text":"<p>Reset the queries and \"close\" the connection.</p>"},{"location":"reference/#asbestos.asbestos.AsbestosCursor.execute","title":"<code>execute(query, inserted_data=None)</code>","text":"<p>Pass SQL to <code>asbestos</code> for processing.</p> <p>Saves the SQL and any passed-in data to the cursor and starts the process of finding your pre-saved response. To get the data, you will need to call one of the fetch* methods listed below.</p>"},{"location":"reference/#asbestos.asbestos.AsbestosCursor.execute_async","title":"<code>execute_async(*args, **kwargs)</code>","text":"<p>Functions the same as <code>.execute()</code>.</p>"},{"location":"reference/#asbestos.asbestos.AsbestosCursor.fetchall","title":"<code>fetchall()</code>","text":"<p>Return the entire saved response.</p> <p>Whereas <code>fetchone</code> will only return the first entry from a saved response, <code>fetchall</code> does what it sounds like it does. Example:</p> <pre><code>config.register(query=\"A\", response=[{'a':1}, {'b': 2}])\nwith asbestos_cursor() as cursor:\n    cursor.execute(\"A\")\n    resp = cursor.fetchall()\n\n# resp = [{'a':1}, {'b': 2}]\n</code></pre>"},{"location":"reference/#asbestos.asbestos.AsbestosCursor.fetchmany","title":"<code>fetchmany(size=None)</code>","text":"<p>Return a paged subset of the saved response.</p> <p>Uses <code>cursor.arraysize</code> to control the page size or just pass your requested page size into the function: <code>.fetchmany(200)</code>. Automatically paginates the response so that you can just keep calling it until you run out of response for it to return. Example:</p> <pre><code>config.register(query=\"A\", response=[{'a':1}, {'b': 2}])\n\ncursor.arraysize = 1  # return one response at a time\nwith asbestos_cursor() as cursor:\n    cursor.execute(\"A\")\n    cursor.fetchmany()  # [{'a':1}]\n    cursor.fetchmany()  # [{'b': 2}]\n    cursor.fetchmany()  # []\n\nNote: a value passed directly into `fetchmany` overrides the\n`cursor.arraysize`, and both of them are overridden by registering\nthe query with `force_pagination_size`.\n</code></pre>"},{"location":"reference/#asbestos.asbestos.AsbestosCursor.fetchone","title":"<code>fetchone()</code>","text":"<p>Return the first result from the saved response for a query.</p> <p><code>fetchone</code> takes a pre-saved query and only gives the first piece of data from the response. Example:</p> <pre><code>config.register(query=\"A\", response=[{'a':1}, {'b': 2}])\nwith asbestos_cursor() as cursor:\n    cursor.execute(\"A\")\n    resp = cursor.fetchone()\n\n# resp = {'a':1}\n</code></pre>"},{"location":"reference/#asbestos.asbestos.AsbestosCursor.get_results_from_sfqid","title":"<code>get_results_from_sfqid(query_id)</code>","text":"<p>Resets the last-run information to the given query ID.</p> <p>If you pass a sfqid from a previously-run query, it will rebuild the cursor using the data from that query, effectively allowing you to run the query again without calling <code>.execute()</code>.</p> <p>Watch out!</p> <p>Ephemeral queries are only recoverable if they are the last query you ran. After you run another query, it will be fully replaced and cannot be recovered via its ID.</p>"},{"location":"reference/#asbestos.asbestos.EphemeralContext","title":"<code>asbestos.asbestos.EphemeralContext</code>","text":"<p>New in 1.6.0!</p> <p>Ephemeral queries are, by definition, single-use. However, ephemeral queries that are paginated are not removed from the list until they are fully exhausted.</p> <p>There are also situations where you may want to have regular queries behave like ephemeral queries, only slightly longer-lasting. The EphemeralContext context manager allows you to wrap a block of code and have all queries run within it removed after the block is done.</p> <pre><code>&gt;&gt;&gt; config.register(query=\"A\", response=\"B\")\n&gt;&gt;&gt; config.register(query=\"C\", response=\"D\")\n&gt;&gt;&gt; len(config.query_map)\n2  # two queries registered\n&gt;&gt;&gt; with EphemeralContext(config):\n&gt;&gt;&gt;     with asbestos_cursor() as cursor:\n&gt;&gt;&gt;         cursor.execute(\"A\")\n&gt;&gt;&gt;         cursor.fetchone()\n\"B\"  # this is the response from the first query\n&gt;&gt;&gt; len(config.query_map)\n1  # the query that was run has been removed, but the other remains\n</code></pre> <p>This works for unlimited numbers of queries of any type.</p>"},{"location":"reference/#asbestos.asbestos.AsbestosConn","title":"<code>asbestos.asbestos.AsbestosConn</code>","text":"<p>Connector to house the Asbestos Cursor object.</p> <p>The real Snowflake connector has two methods for interacting with it: either a cursor object directly (<code>cursor.execute()</code>) or a <code>connection</code> object that is referenced directly (<code>conn.cursor.execute()</code>). Since the goal is that this can be a more-or-less drop-in replacement, we provide an optional connector that can be used to spawn the default cursor.</p> <p>The AsbestosConn doesn't use the default config!</p> <p>If you want to use this, you will need to configure it through the <code>config</code> object that is located on this instance. Example: <pre><code>from asbestos import AsbestosConn\n\nmyconn = AsbestosConn()\nmyconn.config.register(\"select * from...\", {\"MY_EXPECTED\": \"DATA\"})\nwith myconn.cursor() as cursor:\n    ...\n</code></pre></p>"},{"location":"reference/#asbestos.asbestos.AsbestosConn.close","title":"<code>close()</code>","text":"<p>Reset the queries and \"close\" the connection.</p>"},{"location":"reference/#asbestos.asbestos.AsbestosConn.get_query_status","title":"<code>get_query_status(*args)</code>","text":"<p>Check on a currently-running async query.</p> <p>Returns 2, the Snowflake QueryStatus Success value.</p>"},{"location":"reference/#asbestos.asbestos.AsbestosConn.is_still_running","title":"<code>is_still_running(*args)</code>","text":"<p>Check long-running async queries. Will always return False.</p>"},{"location":"reference/#asbestos.exceptions","title":"<code>asbestos.exceptions</code>","text":""},{"location":"reference/#asbestos.exceptions.AsbestosDuplicateQuery","title":"<code>AsbestosDuplicateQuery</code>","text":"<p>               Bases: <code>Exception</code></p> <p>This exception is raised if <code>.register()</code> or <code>.register_ephemeral()</code> are used to create duplicate queries.</p>"},{"location":"reference/#asbestos.exceptions.AsbestosMissingConfig","title":"<code>AsbestosMissingConfig</code>","text":"<p>               Bases: <code>Exception</code></p> <p>This exception is raised if a new cursor is created without passing in an instance of AsbestosConfig.</p>"},{"location":"setup/","title":"Setup","text":"<p>Snowflake offers a few different ways to utilize the library depending on the functionality that you need, so <code>asbestos</code> offers three ways to utilize it.</p> <ul> <li>prebuilt cursor context manager</li> <li>prebuilt conn object</li> <li>manual cursor creation</li> </ul> <p>The first two are equal in terms of usability and are intended as drop-in solutions. If you need something more specific, check out the manual creation!</p>"},{"location":"setup/#prebuilt-cursor-context-manager","title":"Prebuilt Cursor Context Manager","text":"<p>The way that we most commonly use Snowflake at SpotOn is by taking advantage of the fact that Snowflake doesn't check credentials until the first call after instantiating the connector and utilizing a helper function to grab the cursor whenever it's needed. Here's a simplified view of what that looks like in practice:</p> <pre><code>from asbestos import asbestos_cursor\nfrom snowflake import connector as snowflake_connector\nfrom snowflake.connector.connection import SnowflakeConnection\nfrom snowflake.connector.cursor import DictCursor, SnowflakeCursor\n\n\ndef snowflake_connection() -&gt; SnowflakeConnection:\n    # this can be instantiated with null data and it won't explode\n    # until the cursor is created and called.\n    return snowflake_connector.connect(\n        user=settings.SNOWFLAKE_USER,\n        password=settings.SNOWFLAKE_PASSWORD,\n        account=settings.SNOWFLAKE_ACCOUNT,\n        warehouse=settings.SNOWFLAKE_WAREHOUSE,\n        database=settings.SNOWFLAKE_DB,\n        schema=settings.SNOWFLAKE_SCHEMA,\n    )\n\n\ndef snowflake_cursor() -&gt; SnowflakeCursor | AsbestosCursor:\n    # if ENABLE_ASBESTOS is set to True, the real cursor will never\n    # trigger and the connector will never realize that it has bad\n    # data, so we don't have to worry about credentials when testing.\n    if settings.ENABLE_ASBESTOS:\n        return asbestos_cursor()\n    return snowflake_connection().cursor(DictCursor)\n\n\ndef injected_snowflake_cursor(\n        cursor: Optional[AsbestosCursor] = None\n) -&gt; SnowflakeCursor:\n    # If you prefer dependency injection, you can also build it like this!\n    return cursor if cursor else snowflake_connection().cursor(DictCursor)\n</code></pre> <p>In normal usage, this allows us to write queries backed by Snowflake's auto-rollback handling that essentially follow this format:</p> <pre><code>with snowflake_cursor() as cursor:\n    cursor.execute(\"select * from table\")\n    result = cursor.fetchall()\n</code></pre> <p>If you flip the flag for ENABLE_ASBESTOS (or whatever you want to call the flag in your system), it simply returns the mockable cursor instead, which lets you quickly swap between local development, production, and tests. <code>asbestos</code> is set up to make this type of usage as easy as possible.</p>"},{"location":"setup/#prebuilt-conn-object","title":"Prebuilt Conn Object","text":"<p>Sometimes, especially when working with async queries, you need access to the connection object that spawned the cursor. <code>asbestos</code> has a connector that it makes available for just this purpose and can be imported as <code>from asbestos import conn</code>.</p> <p>When using the prebuilt <code>conn</code> object, everything you need to work with the connection is located on that object, including the <code>cursor</code> and the <code>config</code>, which is a special object we'll touch on in a bit. Here's an example using lightly edited async code from the Snowflake documentation:</p> <pre><code>from asbestos import conn\n\ncount_query = \"select count(*) from table(generator(timeLimit =&gt; 25))\"\ncount_query_response = {\"COUNT\": 42}\n\n# tell asbestos to look for this particular query\nconn.config.register(query=count_query, response=count_query_response)\n\ncur = conn.cursor()\ncur.execute_async(\"select count(*) from table(generator(timeLimit =&gt; 25))\")\n# Wait for the query to finish running.\nquery_id = cur.sfqid\nwhile conn.is_still_running(conn.get_query_status(query_id)):\n    pass\n\ncur.get_results_from_sfqid(query_id)\nassert cur.fetchall() == {\"COUNT\": 42}\n</code></pre>"},{"location":"setup/#manual-cursor-creation","title":"Manual Cursor Creation","text":"<p>Hold on!</p> <p>Creating the <code>asbestos</code> connections and cursor is possible, but you're probably going to have a worse time. We recommend using one of the two prebuilt options above if you can.</p> <p>While this method isn't recommended, it is possible. You have two methods here of creating your own cursor with varying amounts of usability.</p>"},{"location":"setup/#manual-setup-with-asbestosconn","title":"Manual Setup with AsbestosConn","text":"<p>The <code>AsbestosConn</code> object is pre-configured to build all the necessary parts automatically when you instantiate it, so the only thing you need to do is import it and instantiate it; then you're good to go!</p> <pre><code>from asbestos import AsbestosConn\n\nmyconn = AsbestosConn()\n</code></pre>"},{"location":"setup/#manual-setup-with-asbestoscursor","title":"Manual Setup with AsbestosCursor","text":"<p>The cursor object is a bit more temperamental and requires the additional setup of a standalone <code>AsbestosConfig</code> object as well, since the <code>AsbestosConfig</code> object controls the cursor. Here's how to set it up:</p> <pre><code>import contextlib\n\nfrom asbestos import AsbestosConfig, AsbestosCursor\n\nmyconfig = AsbestosConfig()\n\n\n@contextlib.contextmanager\ndef asbestos_cursor() -&gt; AsbestosCursor:\n    yield AsbestosCursor(myconfig)\n\n\n# Usage:\nwith asbestos_cursor() as cursor:\n    cursor.execute(...)\n    ...\n</code></pre> <p>It's highly recommended to use one of the other setups if they work for you, as this one just has more moving pieces.</p>"},{"location":"usage/","title":"Usage","text":"<p><code>asbestos</code>' general flow looks like this:</p> <ul> <li>insert the asbestos cursor in whatever way works best for you</li> <li>inform <code>asbestos</code> about your queries and what the expected responses are</li> <li>use it normally!</li> </ul> <p>If you use the recommended setup of the <code>asbestos_cursor()</code> function, then there are two pieces to juggle: the cursor function and the <code>config</code>.</p>"},{"location":"usage/#the-asbestos-config","title":"The <code>asbestos</code> Config","text":"<p>The <code>config</code> object keeps track of all the queries that you've saved and a small handful of additional data. The primary method that you'll be using is called <code>.register()</code>, and it looks like this:</p> <pre><code>from asbestos import config, asbestos_cursor\n\n# This tells asbestos that you're going to pass a base SQL string, and\n# when it sees that specific string, it should respond with the passed-in\n# value.\nconfig.register(query=\"select * from mytable\", response={\"HELLO\": \"WORLD\"})\n\nwith asbestos_cursor() as cursor:\n    cursor.execute(\"select * from mytable\")\n    assert cursor.fetchone() == {\"HELLO\": \"WORLD\"}\n</code></pre> <p>You can register as many queries as you want, and they can be as complex as you want (since they're just strings). You can also register queries that look for specific pieces of data! Since <code>snowflake</code> allows you to pass in SQL and values to substitute, <code>asbestos</code> accepts the same.</p> <pre><code>from asbestos import config, asbestos_cursor\n\nconfig.register(\n    query=\"my very complicated query\",\n    data=(1, 2, 3),\n    response={\"HELLO\": \"WORLD\"}\n)\n\nwith asbestos_cursor() as cursor:\n    cursor.execute(\"my very complicated query\", (1, 2, 3))\n    assert cursor.fetchone() == {\"HELLO\": \"WORLD\"}\n</code></pre> <p>If you have a query that is just the base SQL, it will accept any passed-in extra data:</p> <pre><code>config.register(\n    query=\"my query!\",\n    response={\"HELLO\": \"WORLD\"}\n)\n\nwith asbestos_cursor() as cursor:\n    cursor.execute(\"my query!\", (1, 2, 3))\n    assert cursor.fetchone() == {\"HELLO\": \"WORLD\"}\n</code></pre> <p>But if you register a query that is more complex than what you pass in, it will not match and will return Snowflake's default \"we didn't find anything\" response.</p> <pre><code>config.register(\n    query=\"my very complicated query\",\n    data=(1, 2, 3),\n    response={\"HELLO\": \"WORLD\"}\n)\n\nwith asbestos_cursor() as cursor:\n    cursor.execute(\"my very complicated query\")\n    assert cursor.fetchone() == {}\n</code></pre> <p>The same goes for queries that are registered with data but different data is passed in; only specific matches will trigger.</p>"},{"location":"usage/#single-use-queries","title":"Single-use Queries","text":"<p>For testing purposes, sometimes it's helpful to have a query that can only be run once before vanishing into the ether. You can do that by using <code>config.register_ephemeral()</code>:</p> <pre><code>config.register_ephemeral(\n    query=\"Shhh, I'll only be available once!\",\n    response={\"HELLO\": \"WORLD\"}\n)\n\nwith asbestos_cursor() as cursor:\n    cursor.execute(\"Shhh, I'll only be available once!\")\n    # first time it's there...\n    assert cursor.fetchone() == {\"HELLO\": \"WORLD\"}\n    # second time it's not!\n    assert cursor.fetchone() == {}\n</code></pre>"},{"location":"usage/#resetting-the-query-list","title":"Resetting the Query List","text":"<p>You can remove all the queries loaded by calling <code>config.clear_queries()</code>.</p> <p>Danger!</p> <p>This is a destructive action and will wipe all your registered queries and responses in Asbestos.</p>"},{"location":"usage/#the-cursor","title":"The Cursor","text":"<p>The cursor object has all three fetch methods implemented and can be utilized as expected:</p> <pre><code>config.register(\n    query=\"Hello!\",\n    response=[\n        {\"a\": 1},\n        {\"b\": 2},\n        {\"c\": 3},\n        {\"d\": 4},\n        {\"e\": 5},\n    ],\n)\n\nwith asbestos_cursor() as cursor:\n    cursor.execute(\"Hello!\")\n    assert cursor.fetchone() == {\"a\": 1}\n    assert cursor.fetchall() == [\n        {\"a\": 1},\n        {\"b\": 2},\n        {\"c\": 3},\n        {\"d\": 4},\n        {\"e\": 5},\n    ]\n    cursor.arraysize = 2\n    assert cursor.fetchmany() == [{\"a\": 1}, {\"b\": 2}]\n    assert cursor.fetchmany() == [{\"c\": 3}, {\"d\": 4}]\n    assert cursor.fetchmany() == [{\"e\": 5}]\n</code></pre>"}]}